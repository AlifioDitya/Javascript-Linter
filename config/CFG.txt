S -> SINGULAR_STATEMENT S | EXPRESSION ; S | @epsilon
SINGULAR_STATEMENT -> FUNCTION_DEC | DECLARATION ; | IF_STATEMENT | WHILE_LOOP | DO_WHILE_LOOP | FOR_LOOP | SWITCH_STATEMENT | TRY_STATEMENT | THROW_STATEMENT ; | RETURN_STATEMENT ; | BREAK ; | CONTINUE ; | DELETE ; | @epsilon
IF_STATEMENT -> if ( EXPRESSION ) STATEMENT | if ( EXPRESSION ) STATEMENT else STATEMENT
WHILE_LOOP -> while ( EXPRESSION ) STATEMENT
DO_WHILE_LOOP -> do STATEMENT while ( EXPRESSION )
FOR_LOOP -> for ( FOR_INIT ; EXPRESSION ; EXPRESSION ) STATEMENT | for ( FOR_INIT ; EXPRESSION ; ASSIGNMENT_EXP ) STATEMENT
FOR_INIT -> ASSIGNMENT_EXP | DECLARATION | EXPRESSION
SWITCH_STATEMENT -> switch ( EXPRESSION ) { CASE_STATEMENT }
CASE_STATEMENT -> case EXPRESSION : S BREAK CASE_STATEMENT | case EXPRESSION : S CASE_STATEMENT | DEFAULT_CASE | @epsilon
DEFAULT_CASE -> default : S BREAK | default : S
TRY_STATEMENT -> try { S } catch { S } | try { S } catch ( @varname ) { S } | try { S } finally { S } | try { S } catch { S } finally { S } | try { S } catch ( @varname ) { S } finally { S }
THROW_STATEMENT -> throw EXPRESSION
RETURN_STATEMENT -> return | return RETURN_EXPRESSION
RETURN_EXPRESSION -> EXPRESSION | EXPRESSION , RETURN_EXPRESSION
BREAK -> break
CONTINUE -> continue
DELETE -> delete EXPRESSION
STATEMENT -> { S } | SINGULAR_STATEMENT
DECLARATION -> ASSIGNMENT_EXP | LET_DEC | VAR_DEC | CONST_DEC | FUNCTION_DEC
LET_DEC -> let @varname | let LEFT_HAND_EXP = EXPRESSION | let @varname , DEC_ASSIGNMENT | let LEFT_HAND_EXP = EXPRESSION , DEC_ASSIGNMENT
VAR_DEC -> var @varname | var LEFT_HAND_EXP = EXPRESSION | var @varname , DEC_ASSIGNMENT | var LEFT_HAND_EXP = EXPRESSION , DEC_ASSIGNMENT
CONST_DEC -> const @varname = EXPRESSION | const { DESCTRUCTURE } = EXPRESSION | const @varname = EXPRESSION , CONSTDEC_ASSIGNMENT | const { DESCTRUCTURE } = EXPRESSION , CONSTDEC_ASSIGNMENT
DEC_ASSIGNMENT -> @varname | LEFT_HAND_EXP = EXPRESSION | @varname , DEC_ASSIGNMENT | LEFT_HAND_EXP = EXPRESSION , DEC_ASSIGNMENT
DESCTRUCTURE -> @varname | @varname , DESCTRUCTURE
ASSIGNMENT_EXP  -> LEFT_HAND_EXP = EXPRESSION
CONSTDEC_ASSIGNMENT -> @varname = EXPRESSION | @varname = EXPRESSION , CONSTDEC_ASSIGNMENT
FUNCTION_DEC -> function @varname ( FUNC_PARAMS ) { S } | function @varname ( ) { S }
FUNC_PARAMS -> @varname | { DESCTRUCTURE } | FUNC_PARAMS , FUNC_PARAMS | @epsilon
BOOLEAN -> true | false
LEFT_HAND_EXP -> { DESCTRUCTURE } | @varname | EXPRESSION . LEFT_HAND_EXP
EXPRESSION -> EXPRESSION . EXPRESSION | @varname ( ) | @varname ( FUNC_CALL_PARAMS ) | { OBJ_DEC } | BOOLEAN | null | undefined | @value | @varname | ( EXPRESSION ) | EXPRESSION + EXPRESSION | EXPRESSION @unary_op | @unary_op EXPRESSION | EXPRESSION ? EXPRESSION : EXPRESSION | ASSIGNMENT_EXP
FUNC_CALL_PARAMS ->  EXPRESSION | FUNC_CALL_PARAMS , FUNC_CALL_PARAMS | @epsilon
OBJ_DEC -> @varname : EXPRESSION | @varname : EXPRESSION , OBJ_DEC | @epsilon